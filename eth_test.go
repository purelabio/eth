package eth

//go:generate go run ./gen_eth -out=gen_for_test.go -pkg=eth -self testdata/Test.sol:Test

import (
	"encoding/json"
	"math/big"
	"reflect"
	"strings"
	"testing"

	"github.com/davecgh/go-spew/spew"
)

func init() {
	spew.Config.Indent = "\t"
	spew.Config.ContinueOnMethod = true
}

// For messing around.
func TestMock(t *testing.T) {
}

func TestHexEncodeTo(t *testing.T) {
	src := []byte("one two three")
	out := make([]byte, HexEncodedLen(len(src)))

	err := HexEncodeTo(out, src)
	if err != nil {
		t.Fatalf("%+v", err)
	}

	const nominal = "0x6f6e652074776f207468726565"
	if string(out) != nominal {
		t.Fatalf("expected to encode as %q, got %q", nominal, out)
	}
}

func TestHexDecodeTo(t *testing.T) {
	src := []byte("0x6f6e652074776f207468726565")
	out := make([]byte, HexDecodedLen(len(src)))

	err := HexDecodeTo(out, src)
	if err != nil {
		t.Fatalf("%+v", err)
	}

	const nominal = "one two three"
	if string(out) != nominal {
		t.Fatalf("expected to decode as %q, got %q", nominal, out)
	}
}

func TestHexBytes(t *testing.T) {
	const nominal = "one two three"
	const nominalEncoded = "0x6f6e652074776f207468726565"

	hbytes := HexBytes(nominal)

	coded, err := hbytes.MarshalText()
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if string(coded) != nominalEncoded {
		t.Fatalf("expected to encode as %q, got %q", nominalEncoded, coded)
	}

	hbytes = HexBytes{}
	err = hbytes.UnmarshalText(coded)
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if string(hbytes) != nominal {
		t.Fatalf("expected to encode as %q, got %q", nominal, hbytes)
	}
}

func TestHexInt(t *testing.T) {
	const nominalInt = 123456
	const nominalHex = "0x1e240"

	value := (*HexInt)(new(big.Int).SetInt64(nominalInt))

	if value.String() != nominalHex {
		t.Fatalf("expected to stringify as %q, got %q", nominalHex, value.String())
	}

	coded, err := value.MarshalText()
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if string(coded) != nominalHex {
		t.Fatalf("expected to encode as %q, got %q", nominalHex, value.String())
	}

	value = new(HexInt)

	err = value.UnmarshalText([]byte(nominalHex))
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if (*big.Int)(value).Int64() != nominalInt {
		t.Fatalf("expected to decode as %q, got %q",
			nominalInt, (*big.Int)(value).Int64())
	}
}

func TestHexUint64(t *testing.T) {
	const nominalInt = 123456
	const nominalHex = "0x1e240"

	value := HexUint64(nominalInt)

	if value.String() != nominalHex {
		t.Fatalf("expected to stringify as %q, got %q", nominalHex, value.String())
	}

	coded, err := value.MarshalText()
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if string(coded) != nominalHex {
		t.Fatalf("expected to encode as %q, got %q", nominalHex, value.String())
	}

	value = 0

	err = value.UnmarshalText([]byte(nominalHex))
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if value != nominalInt {
		t.Fatalf("expected to decode as %q, got %q", nominalInt, value)
	}
}

func TestAddress(t *testing.T) {
	var addr Address

	coded, err := addr.MarshalText()
	if err != nil {
		t.Fatalf("%+v", err)
	}
	if string(coded) != "" {
		t.Fatalf("expected to encode as empty string, got %q", coded)
	}

	err = addr.UnmarshalText(nil)
	if err != nil {
		t.Fatalf("%+v", err)
	}
	if addr != (Address{}) {
		t.Fatalf("expected to decode empty input as zero value, got %q", addr)
	}

	nominal := "0x0000000000000000000000000000000000000000"
	if addr.String() != nominal {
		t.Fatalf("expected to stringify as %q, got %q", nominal, addr.String())
	}

	nominal = "0x00a329c0648769a73afac7f9381e08fb43dbea72"
	addr = Address{}

	err = addr.UnmarshalText([]byte(nominal))
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if addr.String() != nominal {
		t.Fatalf("expected to decode as %q, got %q", nominal, addr.String())
	}

	coded, err = addr.MarshalText()
	if err != nil {
		t.Fatalf("%+v", err)
	}

	if string(coded) != nominal {
		t.Fatalf("expected to encode as %q, got %q", nominal, coded)
	}
}

func TestAbiReading(t *testing.T) {
	defs, err := ReadContractDefs(strings.NewReader(mockContractDefs))
	if err != nil {
		t.Fatalf("%+v", err)
	}
	_ = defs
}

func TestAbiEncoding(t *testing.T) {
	for i, test := range abiEncodingSpecs {
		atype, err := ParseAbiType(test.typ)
		if err != nil {
			t.Fatalf("%+v", err)
		}

		out, err := AbiMarshal(atype, test.input)
		if err != nil {
			t.Fatalf("%+v", err)
		}

		actual := HexBytes(out).String()
		expected := test.output
		if actual != expected {
			t.Fatalf("input for ABI encoding at index %v:\n%#v\nABI-encoded output:\n%v\nexpected:\n%v",
				i, test.input, actual, expected)
		}
	}
}

/*
Adapted from:
https://github.com/ethereum/go-ethereum/blob/d3441ebb563439bac0837d70591f92e2c6080303/accounts/abi/pack_test.go#L30
*/
var abiEncodingSpecs = []struct {
	typ    string
	input  interface{}
	output string
}{
	{
		"uint8",
		uint8(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint8[]",
		[]uint8{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint16",
		uint16(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint16[]",
		[]uint16{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint32",
		uint32(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint32[]",
		[]uint32{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint64",
		uint64(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint64[]",
		[]uint64{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint256",
		big.NewInt(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"uint256[]",
		[]*big.Int{big.NewInt(1), big.NewInt(2)},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int8",
		int8(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int8[]",
		[]int8{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int16",
		int16(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int16[]",
		[]int16{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int32",
		int32(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int32[]",
		[]int32{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int64",
		int64(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int64[]",
		[]int64{1, 2},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int256",
		big.NewInt(2),
		"0x0000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"int256[]",
		[]*big.Int{big.NewInt(1), big.NewInt(2)},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002",
	},
	{
		"bytes1",
		[1]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes2",
		[2]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes3",
		[3]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes4",
		[4]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes5",
		[5]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes6",
		[6]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes7",
		[7]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes8",
		[8]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes9",
		[9]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes10",
		[10]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes11",
		[11]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes12",
		[12]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes13",
		[13]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes14",
		[14]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes15",
		[15]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes16",
		[16]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes17",
		[17]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes18",
		[18]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes19",
		[19]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes20",
		[20]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes21",
		[21]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes22",
		[22]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes23",
		[23]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes24",
		[24]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes24",
		[24]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes25",
		[25]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes26",
		[26]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes27",
		[27]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes28",
		[28]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes29",
		[29]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes30",
		[30]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes31",
		[31]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"bytes32",
		[32]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"uint32[2][3][4]",
		[4][3][2]uint32{{{1, 2}, {3, 4}, {5, 6}}, {{7, 8}, {9, 10}, {11, 12}}, {{13, 14}, {15, 16}, {17, 18}}, {{19, 20}, {21, 22}, {23, 24}}},
		"0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000110000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001300000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000015000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000018",
	},
	{
		"address[]",
		[]Address{{1}, {2}},
		"0x000000000000000000000000000000000000000000000000000000000000000200000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000",
	},
	{
		"bytes32[]",
		[]Hash{{1}, {2}},
		"0x000000000000000000000000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"function",
		[24]byte{1},
		"0x0100000000000000000000000000000000000000000000000000000000000000",
	},
	{
		"string",
		"foobar",
		"0x0000000000000000000000000000000000000000000000000000000000000006666f6f6261720000000000000000000000000000000000000000000000000000",
	},

	// Could be wrong. TODO verify.
	{
		"uint8[][]",
		[][]byte{{3, 4}, {5, 6}},
		"0x0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006",
	},
}

func TestAbiMethodEncoding(t *testing.T) {
	abi := TestAbi

	{
		out, err := abi.Function("one").Marshal("test", true, []uint{1, 2, 3})
		if err != nil {
			t.Fatalf("%+v", err)
		}

		actual := HexBytes(out).String()
		expected := `0x55cb92cd0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000474657374000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003`
		if actual != expected {
			t.Fatalf("expected ABI-encoded bytes (%v):\n%v\nactual (%v):\n%v",
				len(expected), expected, len(actual), actual)
		}
	}

	{
		var chunk [10]byte
		_ = append(chunk[:0], "1234567890"...)

		out, err := abi.Function("two").Marshal(uint(0x123), []uint{0x456, 0x789}, chunk, "Hello, world!")
		if err != nil {
			t.Fatalf("%+v", err)
		}

		actual := HexBytes(out).String()
		expected := `0x2615f14400000000000000000000000000000000000000000000000000000000000001230000000000000000000000000000000000000000000000000000000000000080313233343536373839300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004560000000000000000000000000000000000000000000000000000000000000789000000000000000000000000000000000000000000000000000000000000000d48656c6c6f2c20776f726c642100000000000000000000000000000000000000`
		if actual != expected {
			t.Fatalf("expected ABI-encoded bytes (%v):\n%v\nactual (%v):\n%v",
				len(expected), expected, len(actual), actual)
		}
	}

	{
		addr := MustParseAddress("0x00a329c0648769a73afac7f9381e08fb43dbea72")
		out, err := abi.Function("three").Marshal(addr)
		if err != nil {
			t.Fatalf("%+v", err)
		}

		actual := HexBytes(out).String()
		expected := `0x9c82cb2500000000000000000000000000a329c0648769a73afac7f9381e08fb43dbea72`
		if actual != expected {
			t.Fatalf("expected ABI-encoded bytes (%v):\n%v\nactual (%v):\n%v",
				len(expected), expected, len(actual), actual)
		}
	}
}

func TestAbiDecoding(t *testing.T) {
	for i, spec := range abiDecodingUnarySpecs {
		var params []AbiParam
		err := json.Unmarshal([]byte(spec.params), &params)
		if err != nil {
			t.Fatalf("%+v", err)
		}

		ptr := reflect.New(reflect.TypeOf(spec.output))
		err = AbiUnmarshalTuple(spec.input, params, []interface{}{ptr.Interface()})
		output := ptr.Elem().Interface()

		if spec.errMsg != "" {
			if err == nil {
				t.Fatalf("decoding failure at index %v\ninput:\n%v\nusing params:\n%v\nexpected error:\n%v\nactual output:\n%v",
					i, HexBytes(spec.input).String(), spec.params, spec.errMsg, spew.Sdump(output))
			}
			if !strings.Contains(err.Error(), spec.errMsg) {
				t.Fatalf("decoding failure at index %v\ninput:\n%v\nusing params:\n%v\nexpected error:\n%v\nactual error:\n%+v",
					i, HexBytes(spec.input).String(), spec.params, spec.errMsg, err)
			}
			continue
		}

		if err != nil {
			t.Fatalf("decoding failure at index %v\ninput:\n%v\nusing params:\n%v\nexpected output:\n%vactual error:\n%+v",
				i, HexBytes(spec.input), spec.params, spew.Sdump(spec.output), err)
		}

		if !reflect.DeepEqual(output, spec.output) {
			t.Fatalf("decoding failure at index %v\ninput:\n%v\nusing params:\n%v\nexpected output:\n%vactual output:\n%v",
				i, HexBytes(spec.input), spec.params, spew.Sdump(spec.output), spew.Sdump(output))
		}
	}
}

/*
Adapted from:
https://github.com/ethereum/go-ethereum/blob/4b6824e07b1b7c5a2907143b4d122283eadb2474/accounts/abi/unpack_test.go#L53
*/
var abiDecodingUnarySpecs = []struct {
	params string
	input  []byte
	output interface{}
	errMsg string
}{
	{
		params: `[{ "type": "bool" }]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
		output: true,
	},
	{
		params: `[{ "type": "bool" }]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000000"),
		output: false,
	},
	{
		params: `[{ "type": "bool" }]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000001000000000001"),
		output: false,
		errMsg: "malformed bool input",
	},
	{
		params: `[{ "type": "bool" }]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000003"),
		output: false,
		errMsg: "malformed bool input",
	},
	{
		params: `[{"type": "uint32"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
		output: uint32(1),
	},
	// {
	// 	params: `[{"type": "uint32"}]`,
	// 	input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
	// 	output: uint16(0),
	// 	errMsg: "type mismatch",
	// },
	// {
	// 	params: `[{"type": "uint17"}]`,
	// 	input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
	// 	output: uint16(0),
	// 	errMsg: "type mismatch",
	// },
	{
		params: `[{"type": "uint17"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
		output: big.NewInt(1),
	},
	{
		params: `[{"type": "int32"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
		output: int32(1),
	},
	// {
	// 	params: `[{"type": "int32"}]`,
	// 	input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
	// 	output: int16(0),
	// 	errMsg: "type mismatch",
	// },
	// {
	// 	params: `[{"type": "int17"}]`,
	// 	input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
	// 	output: int16(0),
	// 	errMsg: "type mismatch",
	// },
	{
		params: `[{"type": "int17"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001"),
		output: big.NewInt(1),
	},
	{
		params: `[{"type": "address"}]`,
		input:  MustHexParse("0x0000000000000000000000000100000000000000000000000000000000000000"),
		output: Address{1},
	},
	{
		params: `[{"type": "bytes32"}]`,
		input:  MustHexParse("0x0100000000000000000000000000000000000000000000000000000000000000"),
		output: [32]byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	},
	{
		params: `[{"type": "bytes"}]`,
		input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200100000000000000000000000000000000000000000000000000000000000000"),
		output: MustHexParse("0x0100000000000000000000000000000000000000000000000000000000000000"),
	},
	{
		params: `[{"type": "bytes"}]`,
		input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200100000000000000000000000000000000000000000000000000000000000000"),
		output: [32]byte{},
		errMsg: "type mismatch",
	},
	{
		params: `[{"type": "bytes32"}]`,
		input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200100000000000000000000000000000000000000000000000000000000000000"),
		output: []byte(nil),
		errMsg: "type mismatch",
	},
	{
		params: `[{"type": "bytes32"}]`,
		input:  MustHexParse("0x0100000000000000000000000000000000000000000000000000000000000000"),
		output: [32]byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	},
	{
		params: `[{"type": "function"}]`,
		input:  MustHexParse("0x0100000000000000000000000000000000000000000000000000000000000000"),
		output: [24]byte{1},
	},
	{
		params: `[{"type": "uint8[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []uint8{1, 2},
	},
	{
		params: `[{"type": "uint8[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]uint8{1, 2},
	},

	// Seems inconsistent with spec. TODO verify.
	// {
	// 	params: `[{"type": "uint8[][]"}]`,
	// 	input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006"),
	// 	output: [][]uint8{{3, 4}, {5, 6}},
	// },

	{
		params: `[{"type": "uint8[2][2]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2][2]uint8{{1, 2}, {1, 2}},
	},

	// Seems inconsistent with spec. TODO verify.
	// {
	// 	params: `[{"type": "uint8[][2]"}]`,
	// 	input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001"),
	// 	output: [2][]uint8{{1}, {1}},
	// },

	{
		params: `[{"type": "uint8[2][]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [][2]uint8{{1, 2}},
	},
	{
		params: `[{"type": "uint16[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []uint16{1, 2},
	},
	{
		params: `[{"type": "uint16[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]uint16{1, 2},
	},
	{
		params: `[{"type": "uint32[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []uint32{1, 2},
	},
	{
		params: `[{"type": "uint32[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]uint32{1, 2},
	},
	{
		params: `[{"type": "uint32[2][3][4]"}]`,
		input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000110000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001300000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000015000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000018"),
		output: [4][3][2]uint32{{{1, 2}, {3, 4}, {5, 6}}, {{7, 8}, {9, 10}, {11, 12}}, {{13, 14}, {15, 16}, {17, 18}}, {{19, 20}, {21, 22}, {23, 24}}},
	},
	{
		params: `[{"type": "uint64[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []uint64{1, 2},
	},
	{
		params: `[{"type": "uint64[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]uint64{1, 2},
	},
	{
		params: `[{"type": "uint256[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []*big.Int{big.NewInt(1), big.NewInt(2)},
	},
	{
		params: `[{"type": "uint256[3]"}]`,
		input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003"),
		output: [3]*big.Int{big.NewInt(1), big.NewInt(2), big.NewInt(3)},
	},
	{
		params: `[{"type": "int8[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []int8{1, 2},
	},
	{
		params: `[{"type": "int8[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]int8{1, 2},
	},
	{
		params: `[{"type": "int16[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []int16{1, 2},
	},
	{
		params: `[{"type": "int16[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]int16{1, 2},
	},
	{
		params: `[{"type": "int32[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []int32{1, 2},
	},
	{
		params: `[{"type": "int32[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]int32{1, 2},
	},
	{
		params: `[{"type": "int64[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []int64{1, 2},
	},
	{
		params: `[{"type": "int64[2]"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: [2]int64{1, 2},
	},
	{
		params: `[{"type": "int256[]"}]`,
		input:  MustHexParse("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: []*big.Int{big.NewInt(1), big.NewInt(2)},
	},
	{
		params: `[{"type": "int256[3]"}]`,
		input:  MustHexParse("0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003"),
		output: [3]*big.Int{big.NewInt(1), big.NewInt(2), big.NewInt(3)},
	},
}

var abiDecodingVariadicSpecs = []struct {
	params  string
	input   []byte
	outputs []interface{}
	errMsg  string
}{
	{
		params:  `[{"name":"int1","type":"int256"},{"name":"int2","type":"int256"}]`,
		input:   MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		outputs: []interface{}{big.NewInt(1), big.NewInt(2)},
	},
}

// TODO support and test, or remove
var abiDecodingStructSpecs = []struct {
	params string
	input  []byte
	output interface{}
	errMsg string
}{
	{
		params: `[{"name":"int1","type":"int256"},{"name":"int2","type":"int256"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: struct {
			Int1 *big.Int
			Int2 *big.Int
		}{big.NewInt(1), big.NewInt(2)},
	},
	{
		params: `[{"name":"int","type":"int256"},{"name":"Int","type":"int256"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: struct {
			Int1 *big.Int
			Int2 *big.Int
		}{},
		errMsg: "abi: multiple outputs mapping to the same struct field 'Int'",
	},
	{
		params: `[{"name":"int","type":"int256"},{"name":"_int","type":"int256"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: struct {
			Int1 *big.Int
			Int2 *big.Int
		}{},
		errMsg: "abi: multiple outputs mapping to the same struct field 'Int'",
	},
	{
		params: `[{"name":"Int","type":"int256"},{"name":"_int","type":"int256"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: struct {
			Int1 *big.Int
			Int2 *big.Int
		}{},
		errMsg: "abi: multiple outputs mapping to the same struct field 'Int'",
	},
	{
		params: `[{"name":"Int","type":"int256"},{"name":"_","type":"int256"}]`,
		input:  MustHexParse("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"),
		output: struct {
			Int1 *big.Int
			Int2 *big.Int
		}{},
		errMsg: "abi: purely underscored output cannot unpack to struct",
	},
}

func TestAbiMethodDecoding(t *testing.T) {
	abi := TestAbi

	{
		input := MustHexParse(`0x00000000000000000000000000a329c0648769a73afac7f9381e08fb43dbea72000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000`)
		var addr Address
		var str string

		err := abi.Function("four").Unmarshal(input, &addr, &str)
		if err != nil {
			t.Fatalf("%+v", err)
		}

		addrE := MustParseAddress("0x00a329c0648769a73afac7f9381e08fb43dbea72")
		if addr != addrE {
			t.Fatalf("expected to decode %T as %v, got %v", addr, addrE, addr)
		}

		strE := "test"
		if str != strE {
			t.Fatalf("expected to decode %T as %v, got %v", str, strE, str)
		}
	}
}

/*
Generated by:
	solc --combined-json=abi,bin --optimize testdata/Test.sol
*/
const mockContractDefs = `{"contracts":{"testdata/Test.sol:Test":{"abi":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32[]\"},{\"name\":\"\",\"type\":\"bytes10\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"two\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"name\":\"one\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"three\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"four\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","bin":"608060405234801561001057600080fd5b5061032d806100206000396000f3006080604052600436106100615763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632615f144811461006657806355cb92cd1461011f5780639c82cb25146101ba578063a1fca2b6146101e8575b600080fd5b34801561007257600080fd5b5060408051602060046024803582810135848102808701860190975280865261011d9684359636966044959194909101929182918501908490808284375050604080516020601f818a01358b0180359182018390048302840183018552818452989b75ffffffffffffffffffffffffffffffffffffffffffff198b35169b909a9099940197509195509182019350915081908401838280828437509497506102a89650505050505050565b005b34801561012b57600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261011d94369492936024939284019190819084018382808284375050604080516020808901358a01803580830284810184018652818552999c8b3515159c909b909a9501985092965081019450909250829190850190849080828437509497506102ae9650505050505050565b3480156101c657600080fd5b5061011d73ffffffffffffffffffffffffffffffffffffffff600435166102b3565b3480156101f457600080fd5b506101fd6102b6565b604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561026c578181015183820152602001610254565b50505050905090810190601f1680156102995780820380516001836020036101000a031916815260200191505b50935050505060405180910390f35b50505050565b505050565b50565b60408051808201909152600481527f7465737400000000000000000000000000000000000000000000000000000000602082015272a329c0648769a73afac7f9381e08fb43dbea72915600a165627a7a72305820e59621998940576bc6f87fe8a4921a2304c0181d0bd39d5bb23f1d858de784130029"}},"version":"0.4.24+commit.e67f0147.Darwin.appleclang"}`

// TODO more
